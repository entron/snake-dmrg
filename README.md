# Snake DMRG (Snake)

![](1.png)

Snake is a research DMRG code (C++) plus MATLAB helpers for generating model files.
It supports infinite DMRG (iDMRG), finite DMRG (fDMRG), and adaptive real-time evolution (tDMRG) for 1D / impurity-style problems.

## Start here (new to DMRG)

This repo is written for researchers, but it can also be a good “first real codebase” if you’re a new PhD student learning DMRG.
The fastest way to get productive is:

1) run the included MATLAB generator once (see “Quick start” below),
2) reproduce the provided plots from the `results/` files,
3) change **one** physical parameter and rerun,
4) then start doing convergence checks by increasing the kept states (bond dimension) and tightening the truncation criteria.

If you are brand new to the jargon, here is the minimal mental model that will help you navigate the code:

- **DMRG ≈ variational optimization over MPS.** The algorithm searches within the set of matrix product states (MPS) for a low-energy state.
- **Bond dimension / kept states (`m`) controls accuracy.** Larger `m` captures more entanglement but costs more CPU/memory.
- **Truncation error is your “loss of information” dial.** Smaller truncation error generally means better accuracy, but more cost.
- **iDMRG vs fDMRG.** iDMRG is a growth/thermodynamic-limit style procedure; fDMRG uses sweeps on a finite chain to converge a state.
- **tDMRG.** Real-time evolution typically uses Trotter gates; entanglement grows with time, so you often need increasing `m`.

Snake’s current “default run” is a pipeline: iDMRG → fDMRG → tDMRG (see `cppsrc/snake.cpp`).
The run-time input is *not* a text config file: Snake expects a `./model/` directory of binary files generated by the MATLAB scripts.

The intended workflow is:
1) use MATLAB to generate a `model/` directory (binary operators + Hamiltonian terms),
2) run the `Snake` executable in the same folder,
3) read results from `results/`.

## Repository layout

- `cppsrc/`: C++ implementation and build scripts
- `*.m`: MATLAB scripts for generating inputs and plotting outputs
- `README.md`, `1.png`: this documentation and a screenshot/figure

## Build the `Snake` executable

### Dependencies

The C++ code is written against:
- BLAS + LAPACK
- ARPACK
- LAPACK++ (`lapackpp`) headers and library
- A C++ compiler and a Fortran compiler (CMake enables Fortran for LAPACK/ARPACK linkage)

### CMake build (recommended)

From the repo root:

```bash
mkdir -p build
cd build
cmake ..
cmake --build . -j
```

This should produce `build/cppsrc/Snake`.

#### LAPACK++ include/library paths

`cppsrc/CMakeLists.txt` currently assumes LAPACK++ is installed under:
- headers: `$HOME/usr/include/lapackpp`
- libs: `$HOME/usr/lib`

If your LAPACK++ install lives elsewhere, either:
- edit `cppsrc/CMakeLists.txt`, or
- set up symlinks so the above paths exist.

### Notes for new students (common build issues)

- **You need a working BLAS/LAPACK and ARPACK stack.** On many Linux systems this comes from distro packages; on clusters it often comes from environment modules.
- **Fortran matters.** CMake enables Fortran because LAPACK/ARPACK are frequently linked through Fortran toolchains.
- **LAPACK++ is not LAPACK.** This code uses the LAPACK++ C++ wrapper (`lapackpp`) headers and library in addition to BLAS/LAPACK.

## Quick start (run the included MATLAB example)

The scripts in this repo generate a particular impurity + spinless-fermion chain example (see `gen_model.m`).

1) Build `Snake` (see above).
2) In MATLAB (from the repo root), generate a run folder:
   - Note: `gen_model.m` uses `system('cp ...')`, so it assumes a Unix-like shell environment (Linux/macOS, or Windows via WSL); adjust that line if needed.

```matlab
% Example parameters: gen_model(Omega, omegaratio, Lambda, BathL, z)
gen_model(0.05, 1.0, 2.0, 50, 1);
```

This creates a directory named like `ratio...Lambda...BathL...z.../` containing:
- `Snake` (copied from `./build/cppsrc/Snake`)
- `model/` (binary input files for the C++ code)

3) Run Snake inside the generated folder:

```bash
cd ratio1Lambda2BathL50z1   # name depends on your parameters
./Snake
```

4) Inspect outputs in `results/` (see below).

Tip: `Snake` reads `./model/...` relative to your current working directory, so you can also run a binary from elsewhere (e.g. `../../build/cppsrc/Snake`) as long as you `cd` into the run folder first.

## “Accuracy knobs” you should tune first

For DMRG work, getting into the habit of running convergence checks is more important than any single parameter choice.
In Snake, the two most important accuracy controls are currently compile-time defaults:

- **Kept states / bond dimension (`m`)**: `cppsrc/dmrg.cpp` (default `m_KeptStatesNum = 50`)
- **Truncation threshold**: `cppsrc/setting.h` (`Max_Truncate_Error`, default `1e-12`)

Typical workflow for a new project:
1) run with a modest `m`,
2) rerun with larger `m` (e.g. 50 → 100 → 200),
3) check that key observables (and energies, if relevant) stop changing within your desired tolerance,
4) for tDMRG, also check stability versus time step (`rt_tau` in your MATLAB generator) and maximum time (entanglement growth can force larger `m`).

If you want to run only part of the pipeline (e.g., just ground-state DMRG without time evolution), you can edit `cppsrc/snake.cpp` and/or the compile-time flags in `cppsrc/setting.h`, then rebuild.

## Input contract: the `model/` directory

The C++ executable uses fixed relative paths and expects a `./model/` directory next to the executable.
The files are written by `savepara.m` and read by the C++ code:

- `model/problemparmeters.dat` (note the spelling; Snake expects it exactly like this)
  - `int32`: chain length `L`
  - `int32`: target good quantum number `TGQN` (used as a total particle-number-like constraint)
- `model/site_base.dat`: local basis and good-quantum-number information per site (see `sitebase2file.m`)
- `model/site_operators.dat`: on-site operators per site (see `savepara.m`)
- `model/Hfac.dat`: real-valued model parameters (see `savepara.m`)
  - hopping terms, on-site energies, nearest-neighbor interaction terms
- `model/HC.dat`: two-site Hamiltonians for building the starting state (`H0` terms in `gen_model.m`)
- `model/rt_T0.dat`: time-evolution operators for the “bulk” two-site gates
- `model/rt_H1_T0.dat`: time-dependent evolution operators for the impurity + first site

Binary format notes (from `mat2file.m` and the C++ readers in `cppsrc/public.h`):
- integers are written as `int32`
- real scalars are written as `real*8` (IEEE-754 double)
- matrices are written with dimensions followed by raw column-major data (Fortran/MATLAB order)
- complex matrices are written as `(real, imag)` double pairs per element

## Modifying the physics (how to make your own model)

The C++ code assumes you will generate all model inputs from MATLAB into `model/`.
The simplest way to start is to copy `gen_model.m` and make a new generator function for your Hamiltonian.

What `savepara.m` expects in the `para` struct (high level):
- `para.L`, `para.TGQN` and `para.folder`
- `para.site{...}` site definitions (see `genspinsite.m`, `genspinlessfermionsite.m`)
- one-body and two-body parameters written into `Hfac.dat` (`hopT`, `onesiteE`, `twositesV`)
- initial two-site Hamiltonians in `HC.dat` (`para.h0{i}`)
- real-time evolution gates in `rt_T0.dat` and `rt_H1_T0.dat` (for tDMRG runs)

Practical advice for new students:
- Start with a tiny system and compare against exact diagonalization (ED) before trusting large runs.
- If you use symmetries (good quantum numbers), verify they match your Hamiltonian terms; a wrong `TGQN` can silently project you into the wrong sector.
- Change one thing at a time (one parameter or one term), and keep a lab notebook of which generator version produced which `results/`.

## Outputs

`Snake` creates (and overwrites) directories on each run:
- `results/`: kept after the program exits
- `data/`: intermediate blocks; deleted on exit (and also cleared at startup)

Common output files produced by tDMRG (see `cppsrc/SuperChain_tDMRG.cpp`):
- `results/sigmaz_t.dat`: time trace of a local observable (named `sigma_z(t)` in the code)
- `results/vonneumannentropy_t.dat`: von Neumann entropies during evolution
- `results/steperror_t.dat`: placeholder for step-by-step diagnostics (currently created but not written to)
- `results/rdm.dat`: reduced density matrix diagnostics (used by `plotspectral.m`)

File format notes (helpful when you start making your own plots):
- `results/sigmaz_t.dat` contains one value per time step (no explicit time column); the time step size is set by your MATLAB generator (e.g. `rt_tau` in `gen_model.m`).
- `results/vonneumannentropy_t.dat` contains one line per time step; values are space-separated entropies for multiple bipartitions along the chain.

Some provided plotting scripts (run from the parent directory that contains your `ratio...` folders):
- `plotsigmaz.m`
- `plotspectral.m`
- `plotvisibility.m`


## Suggested background reading (DMRG/MPS)

If you want a solid starting point:
- U. Schollwöck, “The density-matrix renormalization group in the age of matrix product states” (Annals of Physics 2011)
- Original DMRG papers by S. R. White (1992/1993)


## Acknowledgements and citation

This program has been developed under the supervision of Prof. Tao Xiang and Prof. Jan von Delft.
Thanks to Shijie Hu, Honggang Luo, Shaojing Qin, Jize Zhao, Hantao Lu, Zhihui Wang and Shuming Li for either direct contribution or discussions during the development of the program.

If you use this code or build on these ideas, please cite:

```
@article{PhysRevB.79.115137,
  title = {Density matrix renormalization group study of a quantum impurity model with Landau-Zener time-dependent Hamiltonian},
  author = {Guo, Cheng and Weichselbaum, Andreas and Kehrein, Stefan and Xiang, Tao and von Delft, Jan},
  journal = {Phys. Rev. B},
  volume = {79},
  issue = {11},
  pages = {115137},
  numpages = {6},
  year = {2009},
  month = {Mar},
  publisher = {American Physical Society},
  doi = {10.1103/PhysRevB.79.115137},
  url = {https://link.aps.org/doi/10.1103/PhysRevB.79.115137}
}
```
